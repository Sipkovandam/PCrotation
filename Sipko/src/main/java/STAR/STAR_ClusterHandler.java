package STAR;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import Slurm.ClusterHandler;
import Slurm.SlurmJob;
import Tools.FileUtils;
import Tools.Script;

public class STAR_ClusterHandler extends SlurmJob implements Cloneable, Serializable
{
	/**
	 * 
	 */
	private static final long serialVersionUID = -6761091153449287175L;
	// STAR specific arguments
	private String genomeDirComment = "/root/genomeDir/; MANDATORY //genome directory readily build using STAR, make sure you use the same settings when creating this directory build the genome";
	private String genomeDir = "";
	private String maxMemoryGenomeBuildComment = "100gb; MANDATORY // Maximum amount of memory the node can to rebuild the genome after the first pass";
	private String maxMemoryGenomeBuild = "180gb";
	private String gTFfileComment = "/root/directory/annotationfile.gtf; MANDATORY // gtf file is used by featurecounts to identify exon boundarys for the expression per exon. Should be the same file as the file used to build the genome (genomeDir)";
	private String gTFfile = null;

	private String sjdbFileChrStartEndComment = "/root/directory/spliceJunctionFile.out.tab; optional // splice junction file from which additional splice junctions are obtained when (re)building the genome index files for STAR";
	private String sjdbFileChrStartEnd = null;
	private String outModeComment = "options are: None/BAM/SAM SortedByCoordinate/Unsorted --limitBAMsortRAM 20000000000; optional // Option to indicate a certain output mode (None --> no BAM or SAM file is created)";
	private String outMode = "BAM Unsorted";
	private String duplicateAddString = null;
	private String keepBAMsContainingComment = "RNA14-00231_S1,RNA14-00254_S7,RNA14-00258_S4; OPTIONAL // Comma separated list of strings. If any of these strings are present in the input files the resulting BAM files are stored after mapping in the second pass";
	private String[] keepBAMsContaining = new String[] { "RNA14-00231_S1", "RNA14-00254_S7", "RNA14-00258_S4" };//if a bam file contains any of these strings it is kept
	private String sTAR_Extra_ArgumentsComment = "--outFilterMismatchNmax 999 --outFilterMismatchNoverLmax 0.04 --alignSJstitchMismatchNmax 1 -1 1 1 --sjdbScore 1 --outFilterMultimapNmax 1 --alignSplicedMateMapLminOverLmate 0.96 --scoreGapNoncan 0 --scoreGap -6 --scoreInsBase 1 --alignSJDBoverhangMin 12 --outSJfilterDistToOtherSJmin 0 0 0 0; OPTIONAL // Additional arguments to STAR that will be included";
	private String sTAR_Extra_Arguments = "--outFilterMismatchNmax 999 --outFilterMismatchNoverLmax 0.04";
	private String countExpressionComment = "true; OPTIONAL // Whether count output files should also be generated by STAR";
	private boolean countExpression = true;
	private String saveGenomeComment = "// Whether the genome files should be stored for future use. Useful when including the same new spice junctions in multiple runs. If true only runs over the first file of a batch.";
	private boolean saveGenome = false;
	//featureCounts arguments
	private String featureCountsComment = "/root/featurecounts/bin/featureCounts; MANDATORY // The executeable of the featurecounts version to be used";
	private String featureCounts = null;
	private String featureCountsOptionsComment = "-p --largestOverlap -f -t exon -O; MANDATORY // options used by featurecounts. -f -t exon maps to exons -O makes sure reads overlapping multiple exons are also counted toward each exon they overlap";
	private String featureCountsOptions = "-p --largestOverlap -f -t exon -O";//"-T 25 --largestOverlap -f -t exon -O"-f -t exon options make sure it counts and reports reads per exon instead of gene ,-O (capital o) option makes sure reads are counted whenever it overlaps multiple genes

	private String pairStringsComment = "[\"_R1_\",\"_R2_\",\"_1.fq\",\"_2.fq\"]; MANDATORY for paired end data // comma separated list of string pairs defining the difference between forward read and backward read files.  For example, immagine a file name fastqFile_1.fq - to obtain the complementary file in this file name _R1_ is replaced iwth _R2_ and _1.fq is replaced with _2.fq. Since _R1_ is not present in the file name but _1.fq is, the complementary file becomes fastqFile_2.fq and these 2 files then are used by STAR. If you files do not contain any of these strings STAR will map the data as if it was single end data";
	private String[] pairStrings = new String[] { "_R1", "_R2", "_1.fq", "_2.fq" };

	private String picardJarFn = null;
	private String samtoolsVersion = "SAMtools/1.3.1-foss-2015b";

	@Override
	public void createSlurmFiles(	String fileNames,
									ClusterHandler slurmVars) throws Exception
	{
		ArrayList<String> fastQ_Files = FileUtils.readArrayList(fileNames);

		System.out.println("Creating slurm files in:\n" + slurmVars.getScriptsFolderName());
		int scriptNumber = 0;
		int fileNumber = 0;
		String tsvFilesToShScriptFN = new File(slurmVars.getScriptsFolderName()).getParent() + "/scriptNumberToFiles.txt";
		BufferedWriter tsvFilenameWriter = FileUtils.createWriter(tsvFilesToShScriptFN);
		BufferedWriter writer = null;
		out: for (int f = 0; f < fastQ_Files.size(); f++)
		{
			if (f == 0 || fileNumber >= slurmVars.getBatchSize())
			{
				scriptNumber++;
				String shellFN = slurmVars.getScriptsFolderName() + scriptNumber + ".sh";
				if (writer != null)
					closeWriter(writer);
				writer = openWriter(shellFN);
				writeSlurmCommands(	writer,
									scriptNumber,
									slurmVars);

				fileNumber = 0;
			}
			String fastqFN = fastQ_Files.get(f);

			// continue if it is the second file of a paired end sequenced sample
			String pairedStringForward = null;
			String pairedStringReverse = null;
			for (int p = 1; p < getPairStrings().length; p += 2)
				if (fastqFN.contains(getPairStrings()[p]))
					continue out;

			for (int p = 0; p < getPairStrings().length; p += 2)
				if (fastqFN.contains(getPairStrings()[p]))
				{
					pairedStringForward = getPairStrings()[p];
					pairedStringReverse = getPairStrings()[p + 1];
				}

			String writeFolder = writeCommandsMapper(	writer,
														fastqFN,
														pairedStringForward,
														pairedStringReverse,
														scriptNumber,
														tsvFilenameWriter,
														slurmVars);

			if (isGenomeBuildRun())
				break;

			echoAndWriteCommand("for file in `ls " + writeFolder + "{*,} | grep -vE \".bam|.idx\"`; do gzip -f $file; done;" ,writer);
			fileNumber++;

		}
		if (writer != null)
			closeWriter(writer);
		tsvFilenameWriter.close();
	}

	private void writeSlurmCommands(BufferedWriter writer,
									int scriptNumber,
									ClusterHandler slurmVars) throws Exception
	{
		slurmVars.writeSlurmCommands(	writer,
										scriptNumber);

		echoAndWriteCommand("STAR --version", writer);
		if(picardJarFn != null)
		{
			echoAndWriteCommand("ml Java", writer);
			echoAndWriteCommand("java -version", writer);
			echoAndWriteCommand("java -jar " + picardJarFn +" MarkDuplicates --version", writer);
		}
		if (samtoolsVersion != null)
		{
			echoAndWriteCommand("ml " + samtoolsVersion, writer);
		}
	}

	private boolean isGenomeBuildRun()
	{
		if (isSaveGenome())
			return true;
		return false;
	}

	public String writeCommandsMapper(	BufferedWriter commandWriter,
										String fn,
										String pairedStringForward,
										String pairedStringReverse,
										int fileNumber,
										BufferedWriter tsvFilenameWriter,
										ClusterHandler slurmVars) throws Exception
	{

		File file = new File(fn);
		
		String writeFolderName = null;

		if (pairedStringForward != null && file.getName().contains(pairedStringForward))
		{
			String outputFolder = file.getName().split(pairedStringForward)[0] + "/";
			
			outputFolder = checkBuild(outputFolder);
			writeFolderName = slurmVars.getSTAR_Folder() + outputFolder;
			echoAndWriteCommand("mkdir " + writeFolderName, commandWriter);
			
			writePairedEndCommand(	file,
									pairedStringForward,
									pairedStringReverse,
									commandWriter,
									fileNumber,
									tsvFilenameWriter,
									slurmVars,
									writeFolderName,
									this.getOutMode());

			String bamFn = writeFolderName + "Aligned.out." + this.getOutMode().toLowerCase().replace(	" unsorted",
																										"").replace(" sortedbycoordinate",
																													"");

			//run featurecounts, but only if deduplication does noet have to happen first.
			if (this.picardJarFn == null && getOutMode() != null && !getOutMode().toLowerCase().equals("none"))
				writeCommandsFeatureCounts(	commandWriter,
											bamFn,
											writeFolderName, slurmVars);
			
			if (this.picardJarFn != null && !isGenomeBuildRun())
			{
				bamFn = writeFolderName + "Aligned.sortedByCoord.out." + this.getOutMode().toLowerCase().replace(	" unsorted",
						"").replace(" sortedbycoordinate",
									"");
				runDeduplicationMode(	writeFolderName,
										pairedStringForward,
										pairedStringReverse,
										bamFn,
										commandWriter,
										slurmVars,
										fileNumber,
										tsvFilenameWriter);
			}

			if(!getOutMode().toLowerCase().equals("none"))
				if (isRemoveBam(bamFn))
				{
					String removeLine = "rm " + bamFn;
					echoAndWriteCommand(removeLine, commandWriter);
				}
				else
					echoAndWriteCommand("samtools index " + bamFn,commandWriter);
		}
		else if (file.getName().contains(".fq") || file.getName().contains(".fastq")) // single end
		{
			//			writeFolderName = writeSingleEndCommand(file,
			//													writer,
			//													fileNumber,
			//													tsvFilenameWriter,
			//													slurmVars, this.getOutMode());
			System.out.println("Warning: STAR Mapping not implemented for single end files");
			System.out.println("Warning: Deduplication not implemented for single end files");

		}

		return writeFolderName;
	}

	private void echoAndWriteCommand(String line, BufferedWriter commandWriter) throws IOException
	{
		commandWriter.write("echo \'"+line.replace("'", "")+"\' | tee /dev/stderr \n");
		commandWriter.write(line+ "\n");
	}

	private void runDeduplicationMode(	String writeFolderName,
										String pairedStringForward,
										String pairedStringReverse,
										String bamFn,
										BufferedWriter writer,
										ClusterHandler slurmVars,
										int fileNumber,
										BufferedWriter tsvFilenameWriter) throws IOException
	{
		String fileDeduplicatedFoward = FileUtils.makeFolderNameEndWithSlash(writeFolderName) + "deduplicated" + pairedStringForward + ".fastq.gz";
		String fileDeduplicatedBackward = FileUtils.makeFolderNameEndWithSlash(writeFolderName) + "deduplicated" + pairedStringReverse + ".fastq.gz";

		writeDeduplicateToFastqLine(bamFn,
									writeFolderName,
									writer,
									slurmVars,
									fileDeduplicatedFoward,
									fileDeduplicatedBackward);

		//overwrites results from the "non_deduplicated" STAR mapping
		String deduplicateFolder = FileUtils.makeFolderNameEndWithSlash(writeFolderName+duplicateAddString);
		
		echoAndWriteCommand("mkdir " + deduplicateFolder , writer);
		
		writePairedEndCommand(	new File(fileDeduplicatedFoward),
								pairedStringForward,
								pairedStringReverse,
								writer,
								fileNumber,
								tsvFilenameWriter,
								slurmVars,
								deduplicateFolder,
								this.getOutMode());

		String duplicateBamFn = FileUtils.makeFolderNameEndWithSlash(deduplicateFolder)+"Aligned.sortedByCoord.out.bam";
		if (getOutMode() != null && !getOutMode().toLowerCase().equals("none"))
			writeCommandsFeatureCounts(	writer,
			                           	duplicateBamFn,
										deduplicateFolder, slurmVars);

		if (isRemoveBam(bamFn))
		{		
			echoAndWriteCommand("rm " + duplicateBamFn, writer);
			echoAndWriteCommand("rm " + fileDeduplicatedFoward, writer);
			echoAndWriteCommand("rm " + fileDeduplicatedBackward, writer);
		}
		else
			echoAndWriteCommand("samtools index " + duplicateBamFn, writer);
		
		echoAndWriteCommand("for file in `ls " + deduplicateFolder + "{*,} | grep -vE \".bam|.idx\"`; do gzip -f $file; done;" + duplicateBamFn, writer);
	}

	private void writeSpliceCounterLine(String deduplicateFn)
	{
		// TODO Auto-generated method stub

	}

	private void writeDeduplicateToFastqLine(	String bamFn,
												String writeFolderName,
												BufferedWriter writer,
												ClusterHandler slurmVars,
												String pairedStringForwardDeduplicated,
												String pairedStringReverseDeduplicated) throws IOException
	{
		String deduplicateFn = bamFn.replace(	".bam",
												"_deduplicated.bam");
		String deduplicateSummaryFn = bamFn.replace(".bam",
													"_deduplicationSummary.txt");

		//kan ook nog samtools rmdup gebruik of extra picard argument REMOVE_DUPLICATES=true
		
		String picardLine = "java -jar "+ picardJarFn +" MarkDuplicates I=" + bamFn + " O=" + "/dev/stdout" + " M=" + deduplicateSummaryFn + " | samtools view -F 0x400 -b | java -jar " + picardJarFn + " SamToFastq I=/dev/stdin " + "F=" + pairedStringForwardDeduplicated + " F2=" + pairedStringReverseDeduplicated;
		echoAndWriteCommand(picardLine, writer);
	}

	private void writePairedEndCommand(	File file,
										String pairedStringForward,
										String pairedStringReverse,
										BufferedWriter writer,
										int fileNumber,
										BufferedWriter tsvFilenameWriter,
										ClusterHandler slurmVars,
										String writeFolder,
										String outPutMode) throws IOException
	{
		// if(iris)//Iris samples need a special treatment because the name of
		// the file is 1 folder higher in the folder hierarchie ><
		// {
		// String[] parentFolders = file.getParent().split("\\\\");
		// outputFolder = file.getName().replace("_1.fq.gz", "")+"/";
		// }

		String fileName = "\"" + file.getName() + "\"";
		fileName = fileName.replace("\\",
									"/");
		String fastqWithPath = file.getPath().replace(	"\\",
														"/");

		writeSTAR_Lines(fastqWithPath,
						pairedStringForward,
						pairedStringReverse,
						writeFolder,
						writer,
						tsvFilenameWriter,
						fileNumber,
						slurmVars,
						outPutMode);
	}

	private String checkBuild(String outputFolder)
	{
		if (isGenomeBuildRun())//in this case do not create a subfolder in the "/1stPassbuild/ or /2ndPassbuild/" folder
			return "";
		return outputFolder;
	}

	private void writeSTAR_Lines(	String fastqWithPath,
									String outputFolder,
									BufferedWriter writer,
									BufferedWriter tsvFilenameWriter,
									int fileNumber,
									ClusterHandler slurmVars,
									String outPutMode) throws IOException
	{
		writeSTAR_Lines(fastqWithPath,
						null,
						null,
						outputFolder,
						writer,
						tsvFilenameWriter,
						fileNumber,
						slurmVars,
						outPutMode);
	}

	private void writeSTAR_Lines(	String fastqWithPath,
									String pairedStringForward,
									String pairedStringReverse,
									String writeFolder,
									BufferedWriter writer,
									BufferedWriter tsvFilenameWriter,
									int fileNumber,
									ClusterHandler slurmvars,
									String outPutMode) throws IOException
	{
		String line = "STAR ";
		if (getSjdbFileChrStartEnd() == null)
			line = line + "--genomeLoad LoadAndKeep ";//The --genomeLoad LoadAndKeep option loads the genome if it's not already loaded, and then starts mapping
		line = line + "--genomeDir " + getGenomeDir() + " --readFilesIn " + fastqWithPath;
		if (pairedStringForward != null)
			line = line + " " + fastqWithPath.replace(	pairedStringForward,
														pairedStringReverse);
		if (getGTFfile() != null && isGenomeBuildRun())//genome should be build with the GTF file included (See STAR manual for how)
			line = line + " --sjdbGTFfile " + getGTFfile();
		line = line + " --outSAMtype " + outPutMode + " --runThreadN " + slurmvars.getThreads() + " --readFilesCommand zcat" + " --outFileNamePrefix " + writeFolder;
		if (getSjdbFileChrStartEnd() != null && getSjdbFileChrStartEnd().length() > 0 && !getSjdbFileChrStartEnd().contentEquals("null"))
			line += " --sjdbFileChrStartEnd " + getSjdbFileChrStartEnd();
		if (getSTAR_Extra_Arguments() != null)
			line += " " + getSTAR_Extra_Arguments();
		if (getCountExpression())
			line += " --quantMode GeneCounts";

		echoAndWriteCommand(line, writer);
		tsvFilenameWriter.write(writeFolder + "Aligned.out.bam" + "\t" + fileNumber + ".sh" + "\t" + fastqWithPath + "\n");

	}

	private void writeCommandsFeatureCounts(BufferedWriter writer,
											String alingedName,
											String outputFolder, ClusterHandler slurmvars) throws IOException
	{
		String featureCountsLine = this.getFeatureCounts() + " " + this.getFeatureCountsOptions() + " -T " + slurmvars.getThreads()  + " -a " + this.getGTFfile() + " -o " + outputFolder + "featureCounts.out " + alingedName;
		echoAndWriteCommand(featureCountsLine, writer);
	}

	private boolean isRemoveBam(String alingedName)
	{
		if (this.getKeepBAMsContaining() == null)
			return true;
		for (String keepString : this.getKeepBAMsContaining())
		{
			if (keepString == null)
				continue;
			if (alingedName != null && alingedName.contains(keepString))
				return false;

		}
		return true;
	}

//	private String writeSingleEndCommand(	File file,
//											BufferedWriter writer,
//											int fileNumber,
//											BufferedWriter tsvFilenameWriter,
//											Slurm slurmVars,
//											String outPutMode) throws IOException
//	{
//		String outputFolder = file.getName().replace(	".fq.gz",
//														"/");
//		outputFolder = checkBuild(outputFolder);
//
//		// if(iris)//Iris samples need a special treatment because the name of
//		// the file is 1 folder higher in the folder hierarchie ><
//		// {
//		// String[] parentFolders = file.getParent().split("\\\\");
//		// outputFolder = parentFolders[parentFolders.length-1]+"/";
//		// }
//		writer.write("mkdir " + slurmVars.getSTAR_Folder() + outputFolder + "\n");
//		String fileName = "\"" + file.getName() + "\"";
//		fileName = fileName.replace("\\",
//									"/");
//		String fastqWithPath = file.getPath().replace(	"\\",
//														"/");
//		writeSTAR_Lines(fastqWithPath,
//						outputFolder,
//						writer,
//						tsvFilenameWriter,
//						fileNumber,
//						slurmVars,
//						outPutMode);
//		return outputFolder;
//	}

	public BufferedWriter openWriter(String shellFN) throws FileNotFoundException, IOException
	{
		BufferedWriter writer = FileUtils.createWriter(shellFN);
		//remove any potential corruptedly loaded genomes before starting
		//writer.write("STAR --genomeLoad Remove --genomeDir " + getSTAR_V().getGenomeDir() +"\n");
		return writer;
	}

	public void closeWriter(BufferedWriter writer) throws IOException
	{
		String starUnloadLine = "STAR --genomeLoad Remove --genomeDir " + getGenomeDir();
		echoAndWriteCommand(starUnloadLine, writer);
		writer.close();
	}

	public String getGenomeDir()
	{
		return genomeDir;
	}

	public String getMaxMemoryGenomeBuild()
	{
		return maxMemoryGenomeBuild;
	}

	public String getGTFfile()
	{
		return gTFfile;
	}

	public String getSjdbFileChrStartEnd()
	{
		return sjdbFileChrStartEnd;
	}

	public String getOutMode()
	{
		return outMode;
	}

	public String[] getKeepBAMsContaining()
	{
		return keepBAMsContaining;
	}

	public String getSTAR_Extra_Arguments()
	{
		return sTAR_Extra_Arguments;
	}

	public boolean getCountExpression()
	{
		return countExpression;
	}

	public String getFeatureCounts()
	{
		return featureCounts;
	}

	public String getFeatureCountsOptions()
	{
		return featureCountsOptions;
	}

	public void setSTAR_Extra_Arguments(String sTAR_Extra_Arguments)
	{
		this.sTAR_Extra_Arguments = sTAR_Extra_Arguments;
	}

	public void setSjdbFileChrStartEnd(String sjdbFileChrStartEnd)
	{
		this.sjdbFileChrStartEnd = sjdbFileChrStartEnd;
	}

	public void setOutMode(	String outMode,
							String duplicateAddString)
	{
		this.outMode = outMode;
		this.duplicateAddString = duplicateAddString;
	}

	public String getgTFfile()
	{
		return gTFfile;
	}

	public void setgTFfile(String gTFfile)
	{
		this.gTFfile = gTFfile;
	}

	public void setsTAR_Extra_Arguments(String sTAR_Extra_Arguments)
	{
		this.sTAR_Extra_Arguments = sTAR_Extra_Arguments;
	}

	public void setGenomeDir(String genomeDir)
	{
		this.genomeDir = genomeDir;
	}

	public void setMaxMemoryGenomeBuild(String maxMemoryGenomeBuild)
	{
		this.maxMemoryGenomeBuild = maxMemoryGenomeBuild;
	}

	public void setKeepBAMsContaining(String[] keepBAMsContaining)
	{
		this.keepBAMsContaining = keepBAMsContaining;
	}

	public void setCountExpression(boolean countExpression)
	{
		this.countExpression = countExpression;
	}

	public void setFeatureCounts(String featureCounts)
	{
		this.featureCounts = featureCounts;
	}

	public void setFeatureCountsOptions(String featureCountsOptions)
	{
		this.featureCountsOptions = featureCountsOptions;
	}

	public STAR_ClusterHandler clone(String jsonFN) throws CloneNotSupportedException
	{
		return (STAR_ClusterHandler) super.clone();
	}

	public boolean isSaveGenome()
	{
		if (saveGenome)
		{
			if (this.sTAR_Extra_Arguments == null)
				this.sTAR_Extra_Arguments = "";
			if (!this.sTAR_Extra_Arguments.contains("sjdbInsertSave All"))
				this.sTAR_Extra_Arguments += " --sjdbInsertSave All";
			if (!this.sTAR_Extra_Arguments.contains("limitSjdbInsertNsj"))
				this.sTAR_Extra_Arguments += " --limitSjdbInsertNsj 10000000";
		}
		return saveGenome;
	}

	public void setSaveGenome(boolean saveGenome)
	{
		this.saveGenome = saveGenome;
	}

	public String[] getPairStrings()
	{
		return pairStrings;
	}

	public void setPairStrings(String[] pairStrings)
	{
		this.pairStrings = pairStrings;
	}

	public String getsTAR_Extra_Arguments()
	{
		return sTAR_Extra_Arguments;
	}

	public String getPicardJarFn()
	{
		return picardJarFn;
	}

	public void setPicardJarFn(String picardVersion)
	{
		this.picardJarFn = picardVersion;
	}

	public String getSamtoolsVersion()
	{
		return samtoolsVersion;
	}

	public void setSamtoolsVersion(String samtoolsVersion)
	{
		this.samtoolsVersion = samtoolsVersion;
	}
}
